# Client-Server 2D Table

## Тестване на приложението

### Server-side
#### Стартиране на сървъра

```
$ cd <projects_dir>\client-server\server
```

```
$ python server.py
```

```
Host:
> 127.0.0.1
Port:
> 1234
```

Алтернативно, може да се подадат `Host` и `Port` като аргменти и да се стартира сървъра по следния начин:

```
$ python server.py 127.0.0.1 1234
```

По подразбиране таблицата е с размер 10х10.

#### Свързване на клиент към сървъра

```
$ cd <projects_dir>\client-server\client
```

```
$ python client.py
```

```
Host:
> 127.0.0.1
Port:
> 1234
```

След успешно свързване в конзолата на сървъра ще се изведе съобщение, подобно на:

```
New connection at ID 0 ('127.0.0.1', 54980)
```

При завършване на задачата на стандартният изход ще се изведе съобщение с измереното време
за извършване на изчисленията:
```
Table filled with 1 processes in 0.10 seconds.
```
### Client-side

Клиентът се стартира през конзолата без аргументи:

`$ python client.py`

Примерен изход на програмата на клиента:
```
Host: 127.0.0.1
Port: 123
Connected to the server.
Input [Table size]: 100
0.0993192195892334
```

Където последният ред ни е върнатата стойност от сървъра и представлява времето, за което се е попълнила таблицата.

## Performance

### Паралелно запълване на 2D таблицата

Използвана е multiprocessing библиотеката за същинска паралелизация на нишките (което го няма при threading, например).
При по-голям вход разликата в производителността се дължи на това, че цялата таблица е разбита
на парчета по равно между различните процеси и паметта на таблицата не е споделена
(всяка нишка си работи изцяло върху собствената си част от таблицата).
Също така забелязваме и зависимостта, че времето за изпълнение намалява с увеличаване на N - броят нишки,
но само до някакъв момент, след което бавно се покачва - нишките стават прекалено много, работата им е малко, и се губи повече време
от менижирането им отколкото се печели с паралелизацията. Оптималният брой нишки за даден вход може да зависи от
от броя ядра на CPU на машината на сървъра, други хардуерни лимитации както и от размера на входа.

| # на нишки | Размер на входа | Средно време за изпълнение, секунди |
|------------|-----------------|-------------------------------------|
| 1          | 100             | 0.10                                |
| 1          | 1000            | 0.12                                |
| 1          | 10 000          | 3.20                                |
| 2          | 10 000          | 2.21                                |
| 3          | 10 000          | 1.98                                |
| 4          | 10 000          | 1.89                                |
| 5          | 10 000          | 2.01                                |
| 10         | 10 000          | 2.11                                |

_Забележка: за повече от size=10 000 хвърляше_
<span style="color:red">*Memory error*</span> и затова нямаме данни.

## Multithreading

Сървърът позволява на няколко клиента да се свършат едновременно
без да се изчакват взаимно заявките им.

Пример: клиент 1 и 2 се свързват едновременно с вход size=10 000,
очаква се стандартният изход на сървъра да изглежда подобен на следния:
```
Host: 127.0.0.1
Port: 123
New connection at ID 0 ('127.0.0.1', 56635)
New connection at ID 1 ('127.0.0.1', 56636)
Table filled with 1 processes in 8.08 seconds.
Table filled with 1 processes in 6.88 seconds.
```

Алтернативен подход е използването на библиотеката `selectors`, за която не остана много време да разуча.

## To-do

- Вместо таблицата да бъде запълвана с детерминирани числа спрямо броя нишки и съответния вход,
може да се запълва със случайни величини във всяка клетка, като нишките продължават да си поделят равномерно работата;
- Вместо клиента да получава само времето за изпълнение може да се върне цялата таблица,
въпреки че за голям вход е непрактично да се принтира таблицата на стандартният вход,
а вместо това може да се записва във отделен файл;

  _Забележка: при използване на multiprocessing таблицата, както и всяка променлива, си има локално копие,
      нямаме споделена памет (а и не искаме); затова всяка нишка трябва работи върху дадена подтаблица,
      която по някакакъв начин трябва да се върне и да се сглоби с останалите подтаблици (което отнема време)._

#

##### _Няколко допълнения:_
###### _requirements.txt е генерирано с pipreqs_
###### _Code explanation > In case of unclearness - contact the developer_
